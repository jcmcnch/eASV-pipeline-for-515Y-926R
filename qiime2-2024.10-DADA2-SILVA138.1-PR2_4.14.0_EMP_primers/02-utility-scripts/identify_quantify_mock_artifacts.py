#!/usr/bin/env python3

import argparse
import pandas as pd
import numpy as np

parser = argparse.ArgumentParser(description='This script parses BLASTn output from your split 18S mock eASV sequences, and summarizing this information in your tsv OTU table of choice.')

parser.add_argument('--tsvasvtable', help='A tab-separated asv table with the format generated by the Fuhrman lab eASV pipeline.')

parser.add_argument('--forwardBLASTout', help='TSV output from your blastn search of your 18S eASVs (R1 only) against the mock sequences.')

parser.add_argument('--reverseBLASTout', help='TSV output from your blastn search of your 18S eASVs (R2 only) against the mock sequences.')

parser.add_argument('--forwardtrim', help='Required for 18s, 1-indexed.')

parser.add_argument('--reversetrim', help='Required for 18s, 1-indexed.')

args = parser.parse_args()

tsvasvout = str(args.tsvasvtable).rsplit('.',1)[0] + ".mockinfo.tsv"
default_outfmt6_cols = 'qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore'.strip().split(' ')

forwardBLASTout = args.forwardBLASTout
fwdBLASTdf = pd.read_csv(forwardBLASTout, header=None, sep='\t')
fwdBLASTdf.columns = default_outfmt6_cols

reverseBLASTout = args.reverseBLASTout
revBLASTdf = pd.read_csv(reverseBLASTout, header=None, sep='\t')
revBLASTdf.columns = default_outfmt6_cols

forwardtrim = int(args.forwardtrim)
reversetrim = int(args.reversetrim)

revBLASTdf = revBLASTdf[(revBLASTdf['length'] >= reversetrim) & (revBLASTdf['gapopen'] == 0)]
fwdBLASTdf = fwdBLASTdf[(fwdBLASTdf['length'] >= forwardtrim) & (fwdBLASTdf['gapopen'] == 0)]

hashALLmockIDs = {}
hashALLmismatchinfo = {}

for i in fwdBLASTdf['qseqid'].unique():

    minloc = fwdBLASTdf.loc[fwdBLASTdf['qseqid'] == i]['mismatch'].idxmin() #Minimum number of mismatches
    fwdmockmatch = fwdBLASTdf.loc[minloc]['sseqid'] #The identifier of the minimum mismatch for the FWD blast results
    revSubFrame = revBLASTdf.loc[revBLASTdf['qseqid'] == i] #A subsetted dataframe containing only results for the given query

    if ( i in list(revBLASTdf['qseqid'].unique()) ) & (fwdmockmatch in list(revSubFrame['sseqid'])):

        minlocrev = revBLASTdf.loc[(revBLASTdf['qseqid'] == i) & (revBLASTdf['sseqid'] == fwdBLASTdf.loc[minloc]['sseqid']) ]['mismatch'].idxmin()

        fwdID = fwdBLASTdf.loc[minloc]['sseqid']
        revID = revBLASTdf.loc[minlocrev]['sseqid']

        fwdmismatches = fwdBLASTdf.loc[minloc]['mismatch']
        revmismatches = revBLASTdf.loc[minlocrev]['mismatch']

        hashALLmismatchinfo[i] = fwdmismatches + revmismatches
        hashALLmockIDs[i] = ';'.join([fwdID, revID])

ASVdf = pd.read_csv(args.tsvasvtable, header=0, index_col="#OTU ID", sep='\t')

ASVdf['BLAST sseqid matches FWD REV'] = ASVdf.index.map(hashALLmockIDs)
ASVdf['Minimum mismatches to mock'] = ASVdf.index.map(hashALLmismatchinfo)

#Reorder
cols = list(ASVdf)
cols.insert(0, cols.pop(cols.index('BLAST sseqid matches FWD REV')))
ASVdf = ASVdf.loc[:, cols]

#Reorder
cols = list(ASVdf)
cols.insert(0, cols.pop(cols.index('Minimum mismatches to mock')))
ASVdf = ASVdf.loc[:, cols]

mockSums = ASVdf[ASVdf['Minimum mismatches to mock'] == 0].sum(axis=0) #Sum the proportions where mismatches = 0 (i.e. perfect hits to mocks)
ASVdf.loc["Sum of mock perfect hits"] = (["", "", ""] + mockSums.tolist()[3:]) #Change series to list

#Reorder
ASVdf = pd.concat([ASVdf.loc[["Sum of mock perfect hits"],:], ASVdf.drop("Sum of mock perfect hits", axis=0).sort_values(by=['Minimum mismatches to mock'])], axis=0)

ASVdf.to_csv(tsvasvout, encoding='utf-8', sep="\t", index=True)
