#!/usr/bin/env python

from Bio import SeqIO
from Bio.Blast.Applications import NcbiblastxCommandline
from Bio.Blast import NCBIXML
import argparse
import pandas as pd
from collections import Counter

parser = argparse.ArgumentParser(description='This script BLASTs your denoised sequences against exact mock sequences, identifying potential artifacts and summarizing this information in your tsv OTU table.')

parser.add_argument('--tsvasvtable', help='A tab-separated asv table with the format generated by the Fuhrman lab eASV pipeline.')

parser.add_argument('--repseqs', help='Your eASV sequences as generated by deblur or DADA2. Must match the ASV table!', default='dna-sequences.fasta')

parser.add_argument('--mockseqs', help='The full path to SSU reference sequences you want to BLAST against, otherwise the script will automatically use the default kraken locations.')

parser.add_argument('--ssu_type', help='16s or 18s.')

parser.add_argument('--forwardtrim', help='Required for 18s, 1-indexed.')

parser.add_argument('--reversetrim', help='Required for 18s, 1-indexed.')

args = parser.parse_args()

forwardtrim = int(args.forwardtrim)
reversetrim = int(args.reversetrim)

if args.ssu_type == "16s" and not args.mockseqs:

    strBLASTdb='/home/db/in-silico-mocks/BLAST-db/16s/mocks_all_non-redundant-renamed-ref.fasta'

elif args.ssu_type == "18s" and not args.mockseqs:

    strBLASTdb='/home/db/in-silico-mocks/BLAST-db/18s/all_seqs_NR_corrected.fasta'

else:

    strBLASTdb=args.mockseqs

default_outfmt6_cols = 'qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore'.strip().split(' ')

if args.ssu_type == "18s":

    forwardout = str(args.repseqs).rsplit('.',1)[0] + ".R1.fa"
    reverseout = str(args.repseqs).rsplit('.',1)[0] + ".R2.fa"
    forwardBLASTout = str(args.repseqs).rsplit('.',1)[0] + ".R1.tsv"
    reverseBLASTout = str(args.repseqs).rsplit('.',1)[0] + ".R2.tsv"

    fwdhandle = open(forwardout, "w+")
    revhandle = open(reverseout, "w+")

    for record in SeqIO.parse(args.repseqs, "fasta"):

        forward = record[0:forwardtrim]
        reverse = record[forwardtrim:]

        SeqIO.write(forward, fwdhandle, "fasta")
        SeqIO.write(reverse, revhandle, "fasta")

    blastx_cline_fwd = NcbiblastxCommandline(cmd='blastn', query=forwardout, qcov_hsp_perc=100, db=strBLASTdb, outfmt=6, out=forwardBLASTout)
    stdout, stderr = blastx_cline_fwd()

    blastx_cline_rev = NcbiblastxCommandline(cmd='blastn', query=reverseout, qcov_hsp_perc=100, db=strBLASTdb, outfmt=6, out=reverseBLASTout)
    stdout, stderr = blastx_cline_rev()

    fwdBLASTdf = pd.read_table(forwardBLASTout, header=None)
    fwdBLASTdf.columns = default_outfmt6_cols

    revBLASTdf = pd.read_table(reverseBLASTout, header=None)
    revBLASTdf.columns = default_outfmt6_cols

    revBLASTdf = revBLASTdf[(revBLASTdf['length'] >= reversetrim) & (revBLASTdf['gapopen'] == 0)]
    fwdBLASTdf = fwdBLASTdf[(fwdBLASTdf['length'] >= forwardtrim) & (fwdBLASTdf['gapopen'] == 0)]

    hashFWDmismatchinfo = {}
    hashREVmismatchinfo = {}

    for i in fwdBLASTdf['qseqid'].unique():

        hashFWDmismatchinfo[i] = fwdBLASTdf.loc[fwdBLASTdf['qseqid'] == i]['mismatch'].min()

    for i in revBLASTdf['qseqid'].unique():

        hashREVmismatchinfo[i] = revBLASTdf.loc[revBLASTdf['qseqid'] == i]['mismatch'].min()

    hashALLmismatchinfo = {}

    for key in hashFWDmismatchinfo:

        hashALLmismatchinfo[key] = hashFWDmismatchinfo[key] + hashFWDmismatchinfo[key]

    pdASV = pd.read_table(args.tsvasvtable, header=0, index_col="#OTU ID")

    pdASV['Minimum mismatches to mock'] = pdASV.index.map(hashALLmismatchinfo)

    mockSums = pdASV[pdASV['Minimum mismatches to mock'] == 0].sum(axis=0)

    pdASV = pdADV.concatenate([mockSums, pdASV])

    pdASV.to_csv("foo.tsv", encoding='utf-8', sep="\t", index=True)
